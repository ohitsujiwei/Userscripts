// ==UserScript==
// @name        Twitch Live Time On Video
// @namespace   Violentmonkey Scripts
// @match       https://www.twitch.tv/*
// @grant       none
// @version     1.0.7
// @author      Nekone
// @description 2025/2/19 上午3:57:17
// @icon        https://www.google.com/s2/favicons?sz=64&domain=twitch.tv
// ==/UserScript==

'use strict'

let global_span = null;
function print(string) {
    global_span ? global_span.textContent = '( ^)o(^ ) -> ' + string : console.log(string);
}

const css_video = `

.live-time-on-video {
    z-index: 1;
    pointer-events: none;
    position: absolute;
    bottom: 0px;
    left: 4px;
    text-shadow: 1px 0px 3px black, -1px 0px 3px black, 0px 1px 3px black, 0px -1px 3px black;
    font-family: system-ui;
    font-size: medium;
}

.quality-button-on-video[checked] {
    border-color: #88D2FF !important;
    background: #FFA6EA !important;
    color: #000000 !important;
    font-weight: bold !important;
}

.latency-mode-toggle-on-video,
.quality-button-on-video {
    padding: 2px;
    margin: 0px 2px;
    border-radius: 4px;
    border-width: 2px;
    border-style: solid;
    border-color: #FFFFFF;
    background: rgba(0, 0, 0, 0.5);
    color: #FFFFFF;
}

p[data-a-target*="player-seekbar"] {
    text-shadow: 1px 0px 3px black, -1px 0px 3px black, 0px 1px 3px black, 0px -1px 3px black;
}

`;

function add_style(css, id) {
    const style = document.createElement('style');
    style.setAttribute('id', id);
    style.textContent = css;
    document.head.appendChild(style);
}

class Formatter {
    static abbr = {
        week: { Sun: '日', Mon: '一', Tue: '二', Wed: '三', Thu: '四', Fri: '五', Sat: '六' },
        month: { Jan: '01', Feb: '02', Mar: '03', Apr: '04', May: '05', Jun: '06', Jul: '07', Aug: '08', Sep: '09', Oct: '10', Nov: '11', Dec: '12' },
    }
    static two_digits(number) {
        return number.toString().padStart(2, '0');
    }
    static time_from_seconds(seconds) {
        const [s, m, h] = [seconds % 60, (seconds / 60) % 60, seconds / 3600].map((e) => Math.floor(e));
        return h > 0 ? `${h}:${this.two_digits(m)}:${this.two_digits(s)}` : `${m}:${this.two_digits(s)}`;
    }
    static date(start_date, seconds) {
        const present_time = new Date((start_date ? Date.parse(start_date) : 0) + Math.floor(seconds * 1000));
        const [week, month, day, year, time] = present_time.toString().split(' ');
        return `${year}/${this.abbr.month[month]}/${day} (${this.abbr.week[week]}) ${time}`;
    }
    static time_to_seconds(time) {
        if (!time) return 0;
        const [s, m, h] = time.split(':').reverse().map((e) => Math.abs(Number(e)));
        const seconds = s + (m || 0) * 60 + (h || 0) * 3600;
        return time[0] == '-' ? -seconds : seconds;
    }
}

class Waitting {
    static head(selector) {
        print(`Watting.head('${selector}');`);
        return this.promise(selector, document.head);
    }
    static body(selector) {
        print(`Watting.body('${selector}');`);
        return this.promise(selector, document.body);
    }
    static promise(selector, observe) {
        return new Promise((resolve) => {
            const observer = new MutationObserver(() => {
                const e = document.querySelector(selector);
                if (e) {
                    observer.disconnect();
                    resolve(e);
                }
            });
            observer.observe(observe, { attributes: false, childList: true, subtree: true });
        });
    }
}

function create_span(selector, text, style) {
    let element = document.querySelector(`.${selector}`);
    if (!element) {
        element = document.createElement('span');
        element.setAttribute('class', selector);
        element.textContent = text || '';
        element.style = style || '';
    }
    return element;
}

function get_video_buffer(video) {
    let seconds = null;
    try { seconds = (video.buffered.end(video.buffered.length - 1) - video.currentTime); }
    catch (e) { seconds = 0.00; }
    finally { return seconds; }
}

async function get_microformat() {
    let microformat = {
        '@type': 'VideoObject',
        'description': '',
        'embedUrl': '',
        'name': '',
        'thumbnailUrl': [],
        'uploadDate': '',
        'publication': {
            '@type': 'BroadcastEvent',
            'endDate': '',
            'startDate': '',
            'isLiveBroadcast': false,
        },
    };
    if (location.href.includes('/videos/')) {
        microformat.publication.startDate = document.querySelector('meta[property="og:video:release_date"]').content;
    }
    else {
        const json = document.querySelector('script[type="application/ld+json"]');
        if (json) microformat = JSON.parse(json.textContent)['@graph'][0];
    }
    return microformat;
}

const text_info_value = {};
function update_text_info_value(objects) {
    text_info_value['time-current'] = objects.current_time?.textContent || '';
    text_info_value['time-separator'] = objects.duration ? '/' : '';
    text_info_value['time-duration'] = objects.duration?.textContent || '';
    text_info_value['status-buffer-health'] = `(B/${objects.buffer ? objects.buffer?.textContent : get_video_buffer(objects.video).toFixed(2)})`;
    text_info_value['status-latency'] = objects.latency ? `(L/${objects.latency?.textContent}/${objects.latency_mode?.textContent})` : '';
    text_info_value['status-view-count'] = objects.viewer_count ? `(V/${objects.viewer_count.textContent})` : '';
    text_info_value['time-date'] = objects.duration ? `(${Formatter.date(objects.microformat?.publication.startDate || '', Formatter.time_to_seconds(objects.current_time?.textContent))})` : '';
    text_info_value['time-now'] = `[${Date().toString().split(' ')[4]}]`;
    text_info_value['video-status'] = `(${objects.video.playbackRate.toFixed(2)}x/${objects.volume.ariaValueText}${objects.quality ? `/${objects.quality}` : ''})`;

    objects.span.textContent = Object.values(text_info_value).join(' ');
}

async function player_settings_process(objects) {
    const selector = {
        player_control_right: '.player-controls__right-control-group',
        player_settings_button: 'button[data-a-target="player-settings-button"]', // to open the settings
        player_settings_menu_item_quality: 'button[data-a-target="player-settings-menu-item-quality"]', // to click the quality option
        player_settings_menu_quality_options: 'div[data-a-target="player-settings-menu"]', // parent of quality options
        player_settings_submenu_quality_option: 'div[data-a-target="player-settings-submenu-quality-option"]', // div of each quality option
        player_settings_root: 'div:has([aria-labelledby="active-settings-menu-header"])', // to hide the process
        player_settings_menu_item_advanced: 'button[data-a-target="player-settings-menu-item-advanced"]', // to click the advanced option
        player_settings_submenu_advanced_video_stats_input: 'div[data-a-target="player-settings-submenu-advanced-video-stats"] input', // to open the stats panel
        player_overlay_video_stats: 'div[data-a-target="player-overlay-video-stats"]', // to hide the stats panel
        video_stats_buffer: 'table p[aria-label="緩衝區大小"]', // to get the buffer
        video_stats_latency: 'table p[aria-label="實況主延遲"]', // to get the latency
        video_stats_latency_mode: 'table p[aria-label="延遲模式"]', // to get the latency mode
        player_settings_submenu_latency_mode_input: 'div[role="menuitemcheckbox"] input[data-a-target="tw-toggle"]',
    };

    function add_button(parent, classname, textContent, onclick) {
        const b = document.createElement('button');
        b.setAttribute('class', classname);
        b.textContent = textContent;
        b.onclick = onclick;
        parent.insertBefore(b, parent.firstChild);
        return b;
    }

    async function add_quality_on_control(control) {
        await Waitting.body(selector.player_settings_button).then((button) => { button.click(); });
        await Waitting.body(selector.player_settings_root).then((root) => { root.style.display = 'none'; });
        await Waitting.body(selector.player_settings_menu_item_quality).then((button) => { button.click(); });
        await Waitting.body(selector.player_settings_menu_quality_options).then(async (div) => {
            div.querySelectorAll(selector.player_settings_submenu_quality_option).forEach((submenu, index) => {
                if (index == 0) return;
                const input = submenu.querySelector('input');
                const label = submenu.querySelector('label').textContent.split(' ')[0];
                const button = add_button(control, 'quality-button-on-video', label, async () => {
                    await Waitting.body(selector.player_settings_button).then((button) => { button.click(); });
                    await Waitting.body(selector.player_settings_root).then((root) => { root.style.display = 'none'; });
                    await Waitting.body(selector.player_settings_menu_item_quality).then((button) => { button.click(); });
                    await Waitting.body(selector.player_settings_menu_quality_options).then((div) => { div.childNodes[index].click(); });
                    await Waitting.body(selector.player_settings_button).then((button) => { button.click(); });
                    objects.quality = label;
                    control.querySelectorAll('.quality-button-on-video').forEach((b) => { b.removeAttribute('checked'); });
                    button.setAttribute('checked', '');
                });
                if (input.checked) {
                    objects.quality = label
                    button.setAttribute('checked', '');
                };
            });
        });
        await Waitting.body(selector.player_settings_button).then((button) => { button.click(); });
    }

    async function open_video_status_panel() {
        await Waitting.body(selector.player_settings_button).then((button) => { button.click(); });
        await Waitting.body(selector.player_settings_root).then((root) => { root.style.display = 'none'; });
        await Waitting.body(selector.player_settings_menu_item_advanced).then((button) => { button.click(); });
        await Waitting.body(selector.player_settings_submenu_advanced_video_stats_input).then((input) => { input.click(); });
        await Waitting.body(selector.player_overlay_video_stats).then(async (div) => {
            div.style.display = 'none';
            objects.buffer = await Waitting.body(selector.video_stats_buffer);
            if (!location.href.includes('/videos/')) {
                objects.latency = await Waitting.body(selector.video_stats_latency);
                objects.latency_mode = await Waitting.body(selector.video_stats_latency_mode);
            }
        });
        await Waitting.body(selector.player_settings_button).then((button) => { button.click(); });
    }

    async function add_latency_mode_toggle_on_control(control) {
        const button = add_button(control, 'latency-mode-toggle-on-video', objects.latency_mode ? objects.latency_mode.textContent : 'Latency', async () => {
            await Waitting.body(selector.player_settings_button).then((button) => { button.click(); });
            await Waitting.body(selector.player_settings_root).then((root) => { root.style.display = 'none'; });
            await Waitting.body(selector.player_settings_menu_item_advanced).then((button) => { button.click(); });
            await Waitting.body(selector.player_settings_submenu_latency_mode_input).then((button) => { button.click(); });
            await Waitting.body(selector.player_settings_button).then((button) => { button.click(); });
            button.textContent = objects.latency_mode ? objects.latency_mode.textContent : 'Latency';
        });
    }

    Waitting.body(selector.player_control_right).then(async (control) => {
        await add_quality_on_control(control);
        await open_video_status_panel();
        await add_latency_mode_toggle_on_control(control);
    });

}

(async function main() {
    try {
        if (['www.twitch.tv', '/directory', '/all'].some(e => !location.href.includes(e))) {
            add_style(css_video, 'twitch-live-time-on-video');

            const objects = {
                'video': null,
                'span': null,
                'current_time': null,
                'duration': null,
                'viewer_count': null,
                'volume': null,
                'microformat': null,
                'quality': null,
                'buffer': null,
                'latency': null,
                'latency_mode': null,
            };
            objects.microformat = await get_microformat();

            objects.video = await Waitting.body('video[webkit-playsinline]');
            objects.span = create_span('live-time-on-video', '( ^)o(^ )');
            objects.video.before(objects.span);
            global_span = objects.span;

            objects.volume = await Waitting.body('input[id*="player-volume-slider"]');

            if (location.href.includes('/videos/')) {
                objects.current_time = await Waitting.body('p[data-a-target="player-seekbar-current-time"]');
                objects.duration = await Waitting.body('p[data-a-target="player-seekbar-duration"]');
            }
            else {
                objects.current_time = await Waitting.body('span.live-time > span');
                Waitting.body('p[data-a-target="animated-channel-viewers-count"]').then((e) => { objects.viewer_count = e; });
            }

            player_settings_process(objects);

            [[objects.current_time, { subtree:true, characterData:true }], [objects.volume, { attributes:true }]].forEach((e) => {
                new MutationObserver(() => { update_text_info_value(objects) }).observe(...e);
            });

            // objects.video.ontimeupdate = () => { update_text_info_value(objects) };

            // const video_container = await wait_element_body('[data-test-selector="video-player__video-container"]')
            // video_container.addEventListener('wheel', (event) => { change_volume_on_wheel(event, video_container, volume) }, { passive: true })
        }
    }
    catch (e) {
        console.log(e);
    }
})();
